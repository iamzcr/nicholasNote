//冒泡排序
/**
arr = [24,69,80,57,13]
原来，让前面的数和后面的数进行比较，如果前面的数大，则交换
第一轮排序开始
第1次比较，24比69小，所以出来结果：[24,69,80,57,13]
第2次比较，69比80小，出来结果：[24,69,80,57,13]
第3次比较，80比57大，所以交换位置，出来结果：[24,69,57,80,13]
第4次比较，80比13大，所以交换位置，出来结果：[24,69,57,13,80]
第一轮排序结束
第二轮排序开始
第1次比较，24比69小，所以出来结果：[24,69,57,13,80]
第2次比较，69比57大，所以交换位置，出来结果：[24,57,69,13,80]
第3次比较，69比13大，所以交换位置，出来结果：[24,57,13,69,80]
第4次比较，因为第一轮排序就确定了80是最大的数，所以没必要比较
第二轮排序结束
第三轮排序开始
第1次比较，24比57小，所以出来结果：[24,57,13,69,80]
第2次比较，57比13大，所以交换位置，出来结果：[24,13,57,69,80]
第3次比较，因为第二轮排序就确定了69和80的排序，所以没必要比较
第三轮排序结束
第四轮排序开始
第1次比较，24比13小，所以出来结果：[13,24,57,69,80]
第2次比较，因为第三轮排序就确定了57，69和80的排序，所以没必要比较
第四轮排序结束
所以结果是[13,24,57,69,80]
规则分析：
1、经过了数组len(arr)-1排序，每一轮将会确定一个数的位置
2、每一次排序的比较次数逐渐减少[4,3,2,1]
3、当发现前面一个数比后面一个数大的时候，就进行交互
*/

package main

import "fmt"

func BubbingSort(arr *[5]int) {
	fmt.Printf("排序前：%v\n", *arr)
	for i := 0; i < len(*arr)-1; i++ {
		temp := 0
		for j := 0; j < len(*arr)-1-i; j++ {
			if (*arr)[j] > (*arr)[j+1] {//从小到大，<从大到小
				//交换
				temp = (*arr)[j]
				(*arr)[j] = (*arr)[j+1]
				(*arr)[j+1] = temp
			}
		}
		fmt.Printf("第%v轮排序后：%v\n", i, *arr)
	}
	/*
		temp := 0
		for j := 0; j < 4; j++ {
			if (*arr)[j] > (*arr)[j+1] {
				//交换
				temp = (*arr)[j]
				(*arr)[j] = (*arr)[j+1]
				(*arr)[j+1] = temp
			}
		}
		fmt.Printf("第一轮排序后：%v\n", *arr)

		for j := 0; j < 3; j++ {
			if (*arr)[j] > (*arr)[j+1] {
				//交换
				temp = (*arr)[j]
				(*arr)[j] = (*arr)[j+1]
				(*arr)[j+1] = temp
			}
		}
		fmt.Printf("第二轮排序后：%v\n", *arr)

		for j := 0; j < 2; j++ {
			if (*arr)[j] > (*arr)[j+1] {
				//交换
				temp = (*arr)[j]
				(*arr)[j] = (*arr)[j+1]
				(*arr)[j+1] = temp
			}
		}
		fmt.Printf("第三轮排序后：%v\n", *arr)
		for j := 0; j < 1; j++ {
			if (*arr)[j] > (*arr)[j+1] {
				//交换
				temp = (*arr)[j]
				(*arr)[j] = (*arr)[j+1]
				(*arr)[j+1] = temp
			}
		}
		fmt.Printf("第四轮排序后：%v\n", *arr)
	*/
}
func main() {
	arr := [5]int{24, 69, 80, 57, 13}
	BubbingSort(&arr)
	fmt.Printf("排序后：%v\n", arr)
}
