###面向对象编程
######步骤，定义结构体，定义属性，定义方法
案例存放在：struct/obj/demo/main.go
######创建结构体变量时候指定属性的值或者创建结构体变量时候指定属性名和属性值写在一起
案例存放在：struct/obj/demo1/main.go
######golang的结构体没有构造函数，可以通过工厂模式来解决这个问题
######使用工厂模式来实现跨包创建结构体实例和访问小写的属性
案例存放在：struct/obj/factroy/main.go
######面向对象思想:抽象，以银行为例
案例存放在：struct/obj/bank/main.go
####封装：封装就是吧抽象出来的属性和对属性的操作封装在一起，数据被保护在内部，程序其他包只有通过备授权的方法才能对属性进行操作
######封装可以隐藏实现细节，可以对数据进行验证，保证安全合理
######封装的实现步骤
```
1、结构体，属性首字母小写，其他包不能使用
2、提供一个类似于构造函数的函数，用于被其他包创建对象
3、提供Set方法，对内部小写属性校验和赋值
4、提供Get方法，获取内部小写属性
```
案例存放在：struct/obj/fengzhuang/person/main.go

####继承
######在golang中，如果一个struct嵌套了另外一个匿名结构体，那么这个结构体可以直接访问匿名结构体的字段和方法，实现继承
案例存放在：struct/obj/jicheng/demo/main.go
######结构体可以使用嵌套匿名结构体的所有属性和方法，也就是继承不区分大小写访问控制
######匿名结构体属性或者方法另外访问方式
案例存放在：struct/obj/jicheng/demo1/main.go
######当结构体和匿名结构体有相同的属性或者方法时，编译器采用就近原则访问，如希望访问匿名结构体的方法和属性，可以通过匿名结构体名来区分
案例存放在：struct/obj/jicheng/demo2/main.go
######结构体嵌入两个或者多个匿名结构体，如果两个匿名结构体有相同的属性或者方法时（同时结构体本身没有同名的属性和方法），在访问的时候，就必须明确指定匿名结构体的名字或者属性，否则编译报错
案例存放在：struct/obj/jicheng/demo3/main.go
######如果一个struct嵌套了一个有名的结构体，这种模式叫组合，如果是组合关系，那么访问组合的结构体的属性或者方法时，必须加上结构体的名字
案例存放在：struct/obj/jicheng/demo4/main.go
######嵌套匿名结构体后，也可以在创建结构体变量的时候，直接指定各个匿名结构体的字段的值
案例存放在：struct/obj/jicheng/demo5/main.go
######结构体是嵌入的时候如果是基本数据类型
案例存放在：struct/obj/jicheng/demo6/main.go
######结构体多重继承，嵌套多个匿名结构体(少用，保证代码的间接性)
案例存放在：struct/obj/jicheng/demo5/main.go

####接口
######golang中多态的特性是由接口来体现的，体现了高内聚，低耦合的思想
######interface可以定义一组方法，但是不需要实现，并且interface不能有任何变量，到某个自定义类型（比如结构体Phone），再根据情况把接口的方法实现
######interface的所有方法都没有方法体，也就是inferface自身不需要实现自己的方法
######golang中，interface不需要显式实现，只要有一个变量，含有接口的所有方法，那么这个变量就实现了该接口
案例存放在：struct/obj/interface/demo/main.go

####接口注意事项
######重要：接口本身不能创建实例，但是可以指向一个实现了该接口的自定义类型的变量(实例)，也就是一个自定义类型只有实现了某个接口，才能将该自定义类型的实例(变量)赋给接口类型
######只要是自定义的数据类型，就可以实现接口，不仅仅是结构体
案例存放在：struct/obj/interface/demo1/main.go
######一个自定义类型可以实现多个接口
案例存放在：struct/obj/interface/demo2/main.go
######一个接口可以继承多个别的接口，这时候如果要实现A接口，也必须将其他接口的方法也全部实现
案例存放在：struct/obj/interface/demo3/main.go
######interface默认是引用类型，如果没有对interface初始化，那么会输出nil
######空接口interface{} 没有任何方法，所以所有类型都实现了空接口，所以我们可以把任何一个变量赋值给空接口
案例存放在：struct/obj/interface/demo4/main.go
######重要：接口实践,实现接口，对自定义数据类型排序
案例存放在：struct/obj/interface/slice/main.go
######重要：接口和继承区别，实现接口可以在不破坏继承的关系下对数据类型增加对应的功能
案例存放在：struct/obj/interface/demo5/main.go
######继承的价值在于解决代码的复用性和可维护性
######接口的价值在于设计，设计好各种规范(方法)，让其他自定义类型实现这些方法
######接口比继承更加灵活，接口满足is-a的关系，而接口只需要满足like-a的关系
######接口一定程度上实现了代码的解耦
####多态
######golang中接口可以体验多态
案例存放在：struct/obj/interface/demo/main.go
######多态数组
案例存放在：struct/obj/interface/demo6/main.go
####类型断言
######由于接口是一般类型，不知道具体类型，如果要转成具体类型，就需要类型断言
案例存放在：struct/obj/duanyan/demo/main.go
######如果几个结构体都实现了同一个接口，但是本身自身有额外的方法，在调用自身的方法的时候就需要断言判断是哪个结构体，去执行对应的方法
案例存放在：struct/obj/duanyan/demo1/main.go
######使用类型断言判断参数类型
案例存放在：struct/obj/duanyan/demo2/main.go

