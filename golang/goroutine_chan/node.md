###goroutine
####内部程序的进程、线程
######进程就是程序在操作系统中一次执行过程，是系统进行资源分配和调度的基本单位
######线程是进程的一个执行实例，是程序执行的最小单元，是比进程更小的能独立运行的基本单位（比如说打开一个迅雷相当进程，每个下载任务相当于一个线程）
######一个进程可以创建和销毁多个线程，同一个进程中的多个线程可以并发执行
######一个程序至少有一个进程，一个进程至少有一个线程
####内部程序的并发、并行(并不是外部的并发请求)
######多线程程序在单核上运行，就是并发
######多线程程序在多核上运行，就是并行
######并发：因为是在一个cpu上，比如有10个线程，每个线程执行10毫秒（进行轮询操作），从人的角度上看，好像这10个线程在同时执行，但是在微观上看，在某一个时间点上看，只有一个线程在执行，这就是并发
######并行：因为是在多个cpu上(比如有10个cpu)，比如有10个线程，每个线程执行10毫秒（各自在不同cpu上执行），从人的角度上看，这10个线程在同时执行，但是在微观上看，在某一个时间点上看，也有10个线程在同时执行，这就是并行
####go协程(goroutine)和go主线程
######go主线程(可以直接称为线程/也可以理解成进程)，一个go主线程上，可以起多个协程，可以把协程理解成轻量级的线程(编译器做了优化)
####go协程特点
######有独立的栈空间
######共享程序的堆空间
######调度由用户(程序员)控制
######协程是轻量级的线程
####MPG模式(goroutine调度模型)
######M：操作系统的主线程(是物理线程)(M本身也有一个G)
######P：协程执行需要的上下文（运行的时候需要的资源）
######G：协程
####设置golang运行cpu数
案例存放在：goroutine_chan/demo1/main.go
####协程并发(并行)资源竞争问题(安全问题)
######查看是否存在资源竞争问题，编译的时候增加一个参数-race即可
案例存放在：goroutine_chan/demo2/main.go
######互斥锁解决资源竞争问题
案例存放在：goroutine_chan/demo3/main.go
####上面的互斥锁解决资源竞争问题缺陷
######1、主线程在等待所有go协程全部执行完成的时间不确定，仅用time.Sleep(time.Second * 10)只是估算
######2、如果主线程等待时间短了，可能还有go协程处于工作状态，这是也会主线程销毁而退出
######3、通过全局变量加锁同步来实现通讯，也并不利于多个协程对全局变量的读写操作
####channel
######channel本质就是一个数据结构-队列
######channel里面的数据是先进先出
######channe本身是线程安全，多个go协程操作同一个channel，不需要加锁
######channel有类型，string只能存放string数据
####channel使用
案例存放在：goroutine_chan/channel/main.go
######在没有使用协程的情况下，如果chan全部取出，没有数据了，继续取会死锁deadlock
######写入数据时候，不能超过一开始初始化的时候定义的容量
######如果存放不同类型的数据，取出的时候需要类型断言才去获取对应的数据，否则编译不通过
####channel关闭和遍历
######使用内置函数close可以关闭channel，关闭后，只能读取数据，不能写数据
######channel遍历的时候，不要使用普通的for循环，要用for-range，而且每次for-range只返回一个值
######channel遍历的时候，如果channel没有关闭，会出现deadlock错误
######channel遍历的时候，如果channel关闭了，则会正常遍历数据，遍历完后，退出遍历
案例存放在：goroutine_chan/channel1/main.go
######channel应用案例
案例存放在：goroutine_chan/channel2/main.go
######运行的时候，如果一个管道的容量比你写进去的数据要少，而且只有写没有读取，会发生阻塞
######协程求素数
案例存放在：goroutine_chan/channel3/main.go
######channel可以声明为只读或者只写性质，默认是读写的(双向)
案例存放在：goroutine_chan/channel4/main.go
######不关闭channel情况下，用select处理阻塞
案例存放在：goroutine_chan/channel5/main.go
######go 协程中使用recover，解决协程中出现panic，导致程序崩溃问题
案例存放在：goroutine_chan/channel_recover/main.go

