类变量/静态变量

静态变量在类加载的时候就生成了
静态变量最大的特点就是被该类的所有对象实例所共享
静态变量可以通过类名直接访问，也可以通过任何一个实例对象访问

静态变量根据版本不同，可能放在堆区（jdk1.7以上版本），也可能放在方法区的静态域，当类加载完成后，会在堆区生成一个class对象，而静态域存储于定义类型的class对象中(了解)

静态变量定义：
访问修饰符 static 数据类型 变量名(推荐)
static 访问修饰符 数据类型 变量名

访问静态变量：
对象名.静态变量
类名.静态变量(推荐)

使用静态变量的情况
当我们需要让某个类的对象共享一个变量时候，就可以考虑使用静态变量

类变量的生命周期随着类的加载而生成，类销毁才销毁

静态方法定义：
访问修饰符 static 数据类型 方法名(推荐)
static 访问修饰符 数据类型 方法名

访问静态方法：
对象名.方法名
类名.方法名(推荐)

类方法的使用场景：
当方法中不涉及任何和对象相关成员的时候(如一些计算，排序，打印)，可以将该方法设计成静态方法，提高开发效率

类方法和普通方法都是随着类的加载而加载。将结构信息存储在方法区
静态方法只能访问静态变量，非静态方法，可以访问静态成员和非静态成员

main方法
main方法是java虚拟机调用的，所以方法访问权限要是public，java虚拟机在执行main方法的时候，不需要创建对象，所以是static
main方法可以接受参数：java 执行程序 参数1，参数2，参数3

代码块：
代码块属于类成员(类的一部分)，类似于方法，将逻辑语句封装在方法体中，{}包围起来
代码块没有方法名，没有返回，没有参数，只有方法体，不用通过对象或者类显式调用，而是加载类或者创建对象时隐式调用

代码块分成两类，使用static修饰的叫静态代码块，没有static修饰的叫普通代码块
代码块里面的逻辑语句可以为任何逻辑语句
；可以写也可以忽略

代码块相对于另外一种形式的构造方法，可以做初始化操作
应用场景：如果多个构造器中都有重复的语句，可以抽取到初始化块中，提高代码的重用性

代码块注意事项：
static代码块作用就是对类进行初始化，而且他随着类的加载而执行，并且只会执行一次，普通代码块，每创建一个对象，就执行

类是什么时候加载的：
创建对象实例时(new)
创建子类对象实例，父类也会被加载
使用类的静态成员(方法和属性)

普通代码块，会在创建对象实例的时候，会被隐式调用，每创建一次，就调用一次
如果只是使用类的静态成员，普通代码块并不会执行

创建对象时，在一个类的调用顺序：
1、调用静态代码块和静态属性初始化，优先级是一样的，如果存在多个，按定义顺序来调用
2、调用普通代码块和普通属性初始化，优先级是一样的，如果存在多个，按定义顺序来调用
3、调用构造方法

构造器其实隐藏了super和调用普通代码块


继承关系的类执行顺序
1、调用父类静态代码块和静态属性初始化，优先级是一样的，如果存在多个，按定义顺序来调用
2、调用子类静态代码块和静态属性初始化，优先级是一样的，如果存在多个，按定义顺序来调用
3、调用父类普通代码块和普通属性初始化，优先级是一样的，如果存在多个，按定义顺序来调用
4、父类构造方法
5、调用子类普通代码块和普通属性初始化，优先级是一样的，如果存在多个，按定义顺序来调用
6、子类构造方法


静态代码块只能直接调用静态成员(静态属性和方法)，普通代码块可以调用任意成员

单例模式：
对某个类只能存在一个实例对象，并且该类只提供一个取得其对象的实例的方法
两种方式：饿汉式，懒汉式
饿汉式：
1、构造器私有化
2、类内部创建对象
3、向外暴露一个静态公共方法
懒汉式：
1、构造器私有化
2、定义一个静态属性对象
3、向外暴露一个静态公共方法,返回一个类对象

final关键字
final可以修饰类，属性，方法，局部变量
使用final的情况
1、类不希望被继承时候，可以用final修饰
2、父类方法不希望被重写，用final
3、不希望类的某个属性被修改，用final
4、局部变量不希望被修改，用final

final修饰的属性又叫常量，一般用xxx_xxx来命名
final修饰的属性在定义时候就必须赋初始值，以后不能再修改，可以在下面位置之一赋值
1、定义的时候（public final double XXX_XXX = 10.2）
2、构造方法中
3、代码块中
final修饰静态属性的时候，初始化位置只能是定义的时候，在静态代码块中，不能再构造方法中
final类不能被继承，但是可以实例化
如果类不是final，但是含有final的方法，该方法不能被重写，但是可以被继承
如果一个类已经是final类，就没必要把方法修饰为final 方法了
final不能修饰构造方法
final和static往往搭配使用效率更高，底层编译器做了优化处理
包装类(Integer,Double,Float等都是final修饰)
