####栈：一般存放基本数据类型(局部变量)
####堆：存放对象，数组等
####方法区，常量池，字符串（java1.7以后，可能会放在堆里面），类加载信息

####一个方法最多只有一个返回值

####递归调用
######一个函数在函数体内又调用了本身，称为递归调用
######函数在递归调用的时，就创建了一个新的受保护的独立空间(新函数栈)
######函数的局部变量是独立的，不会相互影响
######递归必须向退出递归的条件逼近，否则会无限递归
######当一个函数执行完毕，或者遇到return，就会返回，遵守谁调用，就将结果返回给谁，当该函数执行完毕或者返回时，本身也会被销毁

####java中允许同一个类中，多个方法同名存在，但是形参列表不一致，例如 System.out.println();out是PrintStream的类型
####java允许将同一个类中多个同名功能但参数个数不同的方法，封装成一个方法。可以通过可变参数实现

####java中构造方法必须和类名一致，并且没有返回值，但是也不能用void关键词
####一个类定义多个不同的构造方法，即构造方法重载
####构造方法的作用是完成对象的初始化，并不是创建对象
####如果类本身没有定义构造方法，系统会自动给类生成一个默认无参数构造方法，使用javap指令反编译可以查看 javap option(-v,-c) xx.class
####如果类中已经有自定义的构造方法，会覆盖默认的构造方法，如果还想要拥有默认的构造方法，需要显式调用

####this可以调用构造方法:this(参数)，但是只能在构造方法里面使用，而且必须要放在第一条语句
####this不能在类定义外部使用，只能在类定义的方法中使用

包的本质是创建不同的文件夹来保存类文件
包的命名：
com.sina.crm.lib:工具相关
com.sina.crm.user:用户相关

常用的包：
java.lang.* lang包是基本包，默认引入，不需要引入
java.util.* util包是系统提供的工具包，工具类,入Scanner
java.net.* net包是网络包
java.awt.* 做界面开发的包,GUI

包的引入(建议需要什么就引入什么)：
import java.util.Scanner; 只引入java.util的Scanner类
import java.util.*; 把java.util包所有的类都引入

package com.demo; package 的作用是声明当前类所在的包，一个类中最多只有一个package

java的访问修饰符
public ：对外公开，子类，不同包，同类，同包都可以访问
protect：对子类和同一个包中的类公开
private：只有类本身可以访问，不对外公开
默认修饰符：同类，同包可以访问，子类，不同包不能访问

修饰符也可以修饰类，但是类的修饰只能用public和默认修饰符修饰

封装：encapsulation

封装的步骤
1、将属性进行私有化，不能直接修改属性
2、提供一个set方法，用于验证和赋值
3、提供一个get方法，用户权限判断和获取属性的值


继承 extends：

1、子类会自动拥有父类定义的属性和方法，父类又叫超类，基类，子类又叫派生类

2、子类继承了所有的属性和方法，但是私有属性和方法不能在子类直接访问，要通过父类提供公共方法去访问

3、子类必须调用父类的构造方法，完成父类的初始化

4、当创建子类对象时，不管子类使用那个构造方法，默认情况下总会去调用父类的无参构造方法(子类默认会有super()方法)，如果父类没有提供无参构造方法，则必须在子类的构造器中使用super()去指定使用父类的哪个构造方法去完成的对父类的初始化工作，否则，编译不通过

5、如果希望指定去调用父类某个构造方法，需要再子类构造方法中使用super()显示调用

6、super()使用时，要放在构造方法的第一行，而且只能在构造方法中使用

7、super()和this()都只能放在构造器第一行，所以两个方法不能共存在一个构造方法中

8、java所有类都是Object的子类

9、父类构造方法的调用不限于直接父类，将一直往上追溯直到Object类

10、子类最多只能继承一个父类(只直接继承)，java是单继承机制

super的使用：

super代表父类的引用，可以用来访问父类的属性，方法，构造器

super不能访问父类是private修饰的方法和属性(super.属性，super.方法)

super()访问构造器时候，要放在构造方法的第一行

当之类中和父类成员(属性和方法)重名时候，为了访问父类的成员，必须使用super，如果没有重名，使用super，this和直接调用是一样的

super()的访问不限于直接父类，如果爷爷类和本来有同名成员，也可以使用super去访问爷爷类的成员，如果多个基类都有同名成员，采用就近原则

覆盖：

方法覆盖(重写)就是子类一个方法，如果和父类某个方法的名称、返回类型，参数一样，我们就说之类的方法覆盖了父类的方法

方法的返回的类型要和父类一样，或者是父类返回类型的子类，例如父类返回Object，那么子类返回String也是可以的

子类方法不能缩小父类的访问权限

多态(poly)：

方法的多态：
重写和重载都是方法多态的一种体现

对象的多态：
1、一个对象的编译类型和运行类型可以不一致
例如：Animal animal = new Dog()编译类型和运行类型不一致，Animal animal = new Animal()编译类型和运行类型一致
2、编译类型在定义对象的时候就确定了，不能改变
3、运行类型是可以变化的
animal = new Cat():改变运行类型为Cat
4、编译类型看定义时候=号左边，运行类型看=号右边
Animal animal = new Dog();//animal编译类型是Animal，运行类型是Dog
animal = new Cat();//animal运行类型是Cat，编译类型仍然是Animal

多态注意事项：
多态的前提是:两个类存在继承关系
多态的向上转型：
本质：父类的引用指向子类的对象
语法：父类类型 引用名 = new 子类类型
特点：可以调用父类所有成员，要遵循访问修饰符，不能调用子类特有成员(因为在编译阶段，能调用那些成员，是有编译类型决定的)，运行效果看子类的实现

多态的向下转型：
语法：子类类型 引用名 = (子类类型) 父类引用
只能强制转换父类的引用，不能转换父类的对象
要求父类的引用必须指向的是当前目标类型的对象
向下转型后，可以调用子类型中的所有成员

属性没有重写的说法，属性的值看编译类型

instanceOf比较操作符，用于判断对象的运行类型是否为XX类型或者XX类型的子类型

java的动态绑定机制(非常非常重要)
当调用对象方法的时候，该方法和该对象的内存地址/运行类型绑定(方法被重写的了情况下)
当调用对象属性时，没有动态绑定机制，哪里声明，那里使用

多态数组：
数组的定义类型是父类类型，里面保存的实际元素类型为子类型

多态参数：
方法定义的形参类型为父类类型，实参类型允许为子类类型

Object类的常见方法介绍

equals方法

==和equals比较
==既可以判断基本类型，又可以判断引用类型
==如果判断基本类型，判断的是值是否相等
==如果是判断引用类型，判断是地址是否相等

equals是对象中的方法，只能判断引用类型
默认判断地址是否相等，子类中往往重写该方法，用于判断内容(值)是否相等，比如Integer，String

hashCode():返回该对象的哈希码值
提高哈希结构的容器的效率
两个引用，如果指向同一个对象，哈希值是一样的，反之不一样
在集合中hashCode如果有需要的话，也会重写

toString()
默认返回全类名(包名+类名)+@+哈希值的十六进制

finalize()
当对象被回收时，系统自动调用该对象的finalize方法，子类可以重写该方法，做一些释放资源的操作
什么时候对象会被回收：某个对象没有任何引用时，jvm就会认为这个对象是一个垃圾对象，就会使用垃圾回收机制来销毁对象，在销毁改对象前，先调用finalize()
垃圾回收机制的调用，是由系统来决定，也可以通过System.gc()主动触发垃圾回收机制

debug
F7：跳入(跳入方法内)，F8:跳过(逐行执行代码)，shift+F8:跳出(跳出方法)，F9:执行下个断点

多态的体现：
重载，重写都是能体现多态
对象的运行类型和编译类型可以不一致，编译类型在定义的时候就确定，不能变化
对象的运行类型是可以变化，通过object基类的getClass()来查看运行类型